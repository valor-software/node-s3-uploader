// Generated by CoffeeScript 1.8.0
var AWS, Image, S3, Upload, async, fs, gm, hash, rand;

AWS = require('aws-sdk');

S3 = AWS.S3;

fs = require('fs');

gm = require('gm').subClass({
  imageMagick: true
});

async = require('async');

hash = require('crypto').createHash;

rand = require('crypto').pseudoRandomBytes;

Upload = module.exports = function(awsBucketName, opts) {
  if (!awsBucketName) {
    throw new Error('Bucket name can not be undefined');
  }
  AWS.config.update(opts);
  this.s3 = new S3({
    region: (opts != null ? opts.awsBucketRegion : void 0) || 'us-east-1',
    maxRetries: (opts != null ? opts.awsMaxRetries : void 0) || 3,
    sslEnabled: true,
    httpOptions: {
      timeout: (opts != null ? opts.awsHttpTimeout : void 0) || 10000
    },
    params: {
      Bucket: awsBucketName
    }
  });
  this.versions = (opts != null ? opts.versions : void 0) || [];
  this.awsBucketPath = (opts != null ? opts.awsBucketPath : void 0) || '';
  this.awsBucketUrl = "https://s3-" + ((opts != null ? opts.awsBucketRegion : void 0) || 'us-east-1') + ".amazonaws.com/" + awsBucketName + "/";
  this.awsBucketAcl = (opts != null ? opts.awsBucketAcl : void 0) || 'privat';
  this.file = null;
  this.resizeQuality = (opts != null ? opts.resizeQuality : void 0) || 70;
  this.returnExif = (opts != null ? opts.returnExif : void 0) || false;
  this.tmpDir = ((opts != null ? opts.tmpDir : void 0) || require('os').tmpdir()) + '/';
  this.tmpPrefix = 'gm-';
  this.asyncLimit = (opts != null ? opts.asyncLimit : void 0) || 2;
  this._getRandomPath = (opts != null ? opts.getRandomPath : void 0) || function() {
    var i, input, res, x, y, _i;
    input = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    res = [];
    for (i = _i = 1; _i <= 3; i = ++_i) {
      x = input[Math.floor(Math.random() * input.length)];
      y = input[Math.floor(Math.random() * input.length)];
      res.push(x + y);
    }
    return this.awsBucketPath + res.join('/');
  };
  return this;
};

Upload.prototype._uploadPathIsAvailable = function(path, callback) {
  return this.s3.listObjects({
    Prefix: path
  }, function(err, data) {
    if (err) {
      return callback(err);
    }
    return callback(null, path, data.Contents.length === 0);
  });
};

Upload.prototype._uploadGeneratePath = function(callback) {
  return this._uploadPathIsAvailable(this._getRandomPath(), function(err, path, avaiable) {
    if (err) {
      return callback(err);
    }
    if (!avaiable) {
      return callback(new Error("Path '" + path + "' not avaiable!"));
    }
    return callback(null, path);
  });
};

Upload.prototype.upload = function(src, opts, cb) {
  this.file = (opts != null ? opts.file : void 0) || null;
  return this._uploadGeneratePath((function(_this) {
    return function(err, dest) {
      if (err) {
        return cb(err);
      }
      return new Image(src, dest, opts, _this).exec(cb);
    };
  })(this));
};

Image = Upload.Image = function(src, dest, opts, config) {
  this.config = config;
  this.src = src;
  this.dest = dest;
  this.tmpName = hash('sha1').update(rand(128)).digest('hex');
  this.opts = opts || {};
  this.meta = {};
  this.gm = gm(this.src);
  return this;
};

Image.prototype.getMeta = function(cb) {
  return this.gm.identify((function(_this) {
    return function(err, val) {
      if (err) {
        return cb(err);
      }
      _this.meta = {
        format: val.format.toLowerCase(),
        fileSize: val.Filesize,
        imageSize: val.size,
        orientation: val.Orientation,
        colorSpace: val.Colorspace,
        compression: val.Compression,
        quallity: val.Quality,
        exif: _this.config.returnExif ? val.Properties : void 0
      };
      return cb(null, _this.meta);
    };
  })(this));
};

Image.prototype.makeMpc = function(cb) {
  return this.gm.write(this.src + '.mpc', function(err) {
    if (err) {
      return cb(err);
    }
    this.gm = gm(this.src + '.mpc');
    return cb(null);
  });
};

Image.prototype.resize = function(version, cb) {
  var img, _ref;
  version.format = (version != null ? version.format : void 0) || this.meta.format;
  if (version.formatSuffix) {
    version.format += '.' + version.formatSuffix;
  }
  if (version.original) {
    version.src = this.src;
    version.size = this.meta.fileSize;
    version.width = this.meta.imageSize.width;
    version.height = this.meta.imageSize.height;
    return process.nextTick(function() {
      return cb(null, version);
    });
  }
  version.src = [this.config.tmpDir, this.config.tmpPrefix, this.tmpName, version.suffix, "." + version.format].join('');
  img = this.gm.resize(version.maxWidth, version.maxHeight).quality(version.quality || this.config.resizeQuality);
  if (this.meta.orientation) {
    img.autoOrient();
  }
  if ((_ref = this.meta.colorSpace) !== 'RGB' && _ref !== 'sRGB') {
    img.colorspace('RGB');
  }
  return img.write(version.src, function(err) {
    if (err) {
      return cb(err);
    }
    version.width = version.maxWidth;
    delete version.maxWidth;
    version.height = version.maxHeight;
    delete version.maxHeight;
    return cb(null, version);
  });
};

Image.prototype.upload = function(version, cb) {
  var options;
  options = {
    Key: this.dest + version.suffix + '.' + version.format,
    ACL: version.awsImageAcl || this.config.awsBucketAcl,
    Body: fs.createReadStream(version.src),
    ContentType: 'image/' + version.format,
    Metadata: this.opts.metadata || {}
  };
  return this.config.s3.putObject(options, (function(_this) {
    return function(err, data) {
      if (err) {
        return cb(err);
      }
      version.etag = data.ETag.substr(1, data.ETag.length - 2);
      version.path = options.Key;
      if (_this.config.awsBucketUrl) {
        version.url = _this.config.awsBucketUrl + version.path;
      }
      delete version.awsImageAcl;
      delete version.suffix;
      return cb(null, version);
    };
  })(this));
};

Image.prototype.resizeAndUpload = function(version, cb) {
  version.suffix = version.suffix || '';
  return this.resize(version, (function(_this) {
    return function(err, version) {
      if (err) {
        return cb(err);
      }
      return _this.upload(version, cb);
    };
  })(this));
};

Image.prototype.exec = function(cb) {
  return this.getMeta((function(_this) {
    return function(err) {
      return _this.makeMpc(function(err) {
        var versions;
        if (err) {
          return cb(err);
        }
        versions = JSON.parse(JSON.stringify(_this.config.versions));
        return async.mapSeries(versions, _this.resizeAndUpload.bind(_this), function(err, versions) {
          if (err) {
            return cb(err);
          }
          return cb(null, versions, _this.meta);
        });
      });
    };
  })(this));
};
